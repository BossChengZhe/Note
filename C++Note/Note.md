>#  第二章 变量的基本类型
* 左值引用：`int &refval = val`将变量名称`refval`与变量`val`关联起来，相当于`val`的别名，但是不能引用一个常数，引用的初始值必须是一个对象，如`int\string\char\double`等等  
* 一条定义语句可以定义出**不同类型**的变量，比如`int i=1024, *p=&i, &r=i;`中定义出int型变量，指针和引用；同时`*`只作用于最近的变量，将其变为指针而不是整个句子`int* p1, p2`，其中`p1`、`p2`分别是指针和`int`型变量
* `const`
    * 初始化有两种方式，当初始化时复杂的式子(公式、或者函数)**运行**时初始化；如果是常数，则是**编译**时初始化
    * 当多文件都需要使用一个`const`变量时，可以采用`extern`关键字，在A文件中声明，添加`extern`关键字，即可在B文件中使用`const`常量
    * 当`const`左引用一个变量`i`的时候，虽然不可以通过常量改变`i`的值，反过来却可以通过变量`i`改变常量的值，**不知道是不是bug**
    * `const`指针可以指向常量或者变量，指针指向的地址不能变，但是可以改变指针地址指向变量(非常量)的值
    * `const`常量是顶层还是底层，这个问题不是很清楚
* 常量表达式是在**编译**的过程中就能得到计算结果的表达式
* auto表达式：将变量的类型调整为符合表达式的类型，`auto x = val1  + val2`就是将`x`的类型调整为`val1 + val2`结果的类型
* `decltype`：适用于希望从表达式的类型推断出要定义的变量的类型，但是又不想用表达式的值初始化，`decltype(f()) sum = x`,其中`sum`的类型就是函数`f()`的类型；注意当`decltype((i))`,就得到`i`的引用
* `#ifdef`、`#ifndef`、`#endif`、`#define`:
    * `#ifdef`当且仅当变量已定义时为真
    * `#ifndef`当且仅当变量未定义时为真，一旦未定义执行到`#endif`
    * `#define`将名字设定为预处理变量
    > 当第一次包含头文件时，`#ifndef`为真，预处理器将顺序执行后面直到`#endif`，下一次包含头文件时，`#ifndef`为假，将跳过直到`#endif`

># 字符串、向量和数组
* `cctype`头文件中可以对`string`类型的中元素进行多种操作，例如将将小写字母改为大写字母，统计标点符号等等(Page.82)
* `string.size()`返回的并不是常说的`int`型，而是`size_type`，在日常运用中发生了强制类型转换
* 在早期C++标准中，如果`vector`中的元素还是`vector`，则需要`vector<vector<int> >`这样声明，要加**空格**，新标准中没有类似的要求
* `vector`初始化问题
    * 初始化基本方式如下图，很多种是等价的方式
    * 如果`vector`中的元素不支持默认初始化，我们就必须提供初始值
    * 初始化时，圆括号值得时元素的个数，而花括号是指对`vector`中的元素赋值；**但是**，当花括号中的元素跟容器中的元素类型不同时，编译器就会尝用默认值初始化`vector`对象
<div align=center>
<img src='../Image/Init_Vector.png'>
<img src='../Image/Special_init_Vector.png'>
</div>

* `vector`可以直接判断`==`，当且仅当元素个数相同并且`vector`对应位置元素相同；`vector`不支持通过下标添加元素，即下标只支持对已经存在的元素操作
> **迭代器**
<div>
<img src="../Image/iterator.png">
</div>

* `end()`指向的是`vector`中的**不存在**的尾后元素，这个元素并没有什么意义，当`vector`是空的，`begin()`和`end()`是同一个迭代器
* `->`是解引用和访问成员函数的结合体，`(*item).mem`等价于`item->mem`
* 使用迭代器的`vector`对象，都不能对象容器中添加或者删去元素
![迭代器操作](../Image/OP_Iter.png)

**********************************************
* 在很多用到数组名字的地方，编译器会自动的将其替换为一个数组首元素的指针；同时可利用库函数`begin(arr)`、`end(arr)`得到指向数组开头和结尾的指针，与`vector.end()`类似，都是指向不存在的尾后指针，尾后指针不能执行解引用和递增操作 