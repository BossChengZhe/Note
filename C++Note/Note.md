>#  第二章 变量的基本类型
* 左值引用：`int &refval = val`将变量名称`refval`与变量`val`关联起来，相当于`val`的别名，但是不能引用一个常数，引用的初始值必须是一个对象，如`int\string\char\double`等等  
* 一条定义语句可以定义出**不同类型**的变量，比如`int i=1024, *p=&i, &r=i;`中定义出int型变量，指针和引用；同时`*`只作用于最近的变量，将其变为指针而不是整个句子`int* p1, p2`，其中`p1`、`p2`分别是指针和`int`型变量
* `const`
    * 初始化有两种方式，当初始化时复杂的式子(公式、或者函数)**运行**时初始化；如果是常数，则是**编译**时初始化
    * 当多文件都需要使用一个`const`变量时，可以采用`extern`关键字，在A文件中声明，添加`extern`关键字，即可在B文件中使用`const`常量
    * 当`const`左引用一个变量`i`的时候，虽然不可以通过常量改变`i`的值，反过来却可以通过变量`i`改变常量的值，**不知道是不是bug**
    * `const`指针可以指向常量或者变量，指针指向的地址不能变，但是可以改变指针地址指向变量(非常量)的值
    * `const`常量是顶层还是底层，这个问题不是很清楚
* 常量表达式是在**编译**的过程中就能得到计算结果的表达式
* auto表达式：将变量的类型调整为符合表达式的类型，`auto x = val1  + val2`就是将`x`的类型调整为`val1 + val2`结果的类型
* `decltype`：适用于希望从表达式的类型推断出要定义的变量的类型，但是又不想用表达式的值初始化，`decltype(f()) sum = x`,其中`sum`的类型就是函数`f()`的类型；注意当`decltype((i))`,就得到`i`的引用
* `#ifdef`、`#ifndef`、`#endif`、`#define`:
    * `#ifdef`当且仅当变量已定义时为真
    * `#ifndef`当且仅当变量未定义时为真，一旦未定义执行到`#endif`
    * `#define`将名字设定为预处理变量
    > 当第一次包含头文件时，`#ifndef`为真，预处理器将顺序执行后面直到`#endif`，下一次包含头文件时，`#ifndef`为假，将跳过直到`#endif`

># 字符串、向量和数组
* `cctype`头文件中可以对`string`类型的中元素进行多种操作，例如将将小写字母改为大写字母，统计标点符号等等(Page.82)
* `string.size()`返回的并不是常说的`int`型，而是`size_type`，在日常运用中发生了强制类型转换
* 在早期C++标准中，如果`vector`中的元素还是`vector`，则需要`vector<vector<int> >`这样声明，要加**空格**，新标准中没有类似的要求
* `vector`初始化问题
    * 初始化基本方式如下图，很多种是等价的方式
    * 如果`vector`中的元素不支持默认初始化，我们就必须提供初始值
    * 初始化时，圆括号值得时元素的个数，而花括号是指对`vector`中的元素赋值；**但是**，当花括号中的元素跟容器中的元素类型不同时，编译器就会尝用默认值初始化`vector`对象
* `vector`清理所有元素的三种方法
    * `vector.clear()`:清除当前容器中所有的元素，但是**不清除内存空间**
    * `vector.erase()`:清除当前容器中所有的元素，但是**不清除内存空间**
    * `vector<T>().swap(Ob)`:调用vector的构造函数，构建一个临时`vector`对象，与 `Ob`交换内存空间，此时 `Ob`已经是没有任何元素的空的 `vector`，而临时`vector`对象在生命周期结束时，析构函数帮助清理内存，所以这种方法时能够清理内存的，但是不是**直接清理**，而是通过互换内存和`vector`析构函数实现的

<div align=center>
<img src='../Image/Init_Vector.png'>
<img src='../Image/Init_string.png'>
<img src='../Image/Special_init_Vector.png'>
</div>

* `vector`可以直接判断`==`，当且仅当元素个数相同并且`vector`对应位置元素相同；`vector`不支持通过下标添加元素，即下标只支持对已经存在的元素操作
> **迭代器**
<div>
<img src="../Image/iterator.png">
</div>

* `end()`指向的是`vector`中的**不存在**的尾后元素，这个元素并没有什么意义，当`vector`是空的，`begin()`和`end()`是同一个迭代器
* `->`是解引用和访问成员函数的结合体，`(*item).mem`等价于`item->mem`
* 使用迭代器的`vector`对象，都不能对象容器中添加或者删去元素
![迭代器操作](../Image/OP_Iter.png)
<div align=center>
<img src="../Image/Judge_character.png">
</div>

**********************************************
* 在很多用到数组名字的地方，编译器会自动的将其替换为一个数组首元素的指针；同时可利用库函数`begin(arr)`、`end(arr)`得到指向数组开头和结尾的指针，与`vector.end()`类似，都是指向不存在的尾后指针，尾后指针不能执行解引用和递增操作 

> # 第三章   表达式
* 有4种运算符明确规定了运算对象的求值顺序。逻辑与(&)运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。另外三种分别是逻辑或(||)运算符、条件(?:)运算符和逗号(,)运算符
    * 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值
    * 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值

* **后置递增运算符的优先级高于解引用运算符**，因此`*pbeg++`等价于`*(pbeg++)`。`pbeg++`把`pbeg`的值加1，然后返回`pbeg`的初始值的副本作为其求值结果，此时解引用运算符的运算对象是`pbeg`未增加之前的值。最终，这条语句输出`pbeg`开始时指向的那个元素，并将指针向前移动一个位置。
* sizeof运算符的结果部分地依赖于其作用的类型：
    * 对char或者类型为char的表达式执行sizeof运算，结果得1.
    * 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
    * 对指针执行sizeof运算得到指针本身所占空间的大小。
    * 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。
    * 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意， **sizeof运算不会把数组转换成指针来处理**。
        ```C++
        // sizeof(ia) /sizeof(*ia)返回ia的元素数量
        constexpr size t sz = sizeof(ia) /sizeof(*ia);
        int arr2[sz]； //正确： sizeof返回一个常量表达式
        ```
    * 对string对象或vector对象执行sizeof运算只返回该类型**固定部分的大小**，不会计算对象中的元素占用了多少空间。
* 无符号类型的运算对象
    * 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是`unsigned int`和`int`,则`int`类型的运算对象转换成`unsigned int`类型。需要注意的是，如果`int`型的值恰好为负值，其结果将以2.1.2节（第32页）介绍的方法转换，并带来该节描述的所有副作用。
    * 剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是`1ong`和`unsigned int`，并且`int`和`1ong`的大小相同，则`long`类型的运算对象转换成`unsigned int`类型：如果`long`类型占用的空间比`int`更多，则`unsigned int`类型的运算对象转换成`1ong`类型。
* 强制类型转换`cast-name<type>(expression);`
    * `static_ cast`：任何具有明确定义的类型转换，只要不包含底层`const`，都可以使用`static_cast`例如，通过将一个运算对象强制转换成`double`类型就能使表达式执行浮点数除法,当需要把一个**较大的算术类型赋值给较小的类型**时，`static_cast`非常有用。当我们把指针存放在void*中，并且使用static—cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，**强制转换的结果将与原始的地址值相等**，因此我们必须**确保转换后所得的类型就是指针所指的类型**。
    ```C++
    double slope = static_cast<double>(a)/b;
    void* p = &d；              //正确：任何非常量对象的地址都能存入void*
    double *dp = static_cast    //正确：将void*转换回初始的指针类型
    ```
    * `const_cast`:去`const`,只能改变运算对象的底层`const`，只有`const_cast`能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用`const_cast`改变表达式的类型。
    ```C++
    const char *cp;
    char *q = static_cast<char*>(cp);    //错误： static_cast不能转换掉const性质
    static_cast<string>(cp);             // 正确：字符串字面值转换成string类型
    const_cast<string>(cp);              // 错误：const_cast只改变常量属性，不能改变数据的类型(char->string)
    ```
    * `reinterpret_cast`：通常为运算对象的位模式提供较低层次上的重新解释
    ```C++
    int *ip;
    char *pc = reinterpret_cast<char*>(ip);
    ```