## java面试难点总结

#### 一、Java基础知识

1. 同步、异步、阻塞和非阻塞IO的区别：

   >https://www.cnblogs.com/loveer/p/11479249.html
   >
   >https://www.cnblogs.com/javaguide/p/io.html
   >
   >https://www.jianshu.com/p/5bb812ca5f8e

   * 同步阻塞方式：发送方发送请求之后一直等待响应。接收方处理请求时进行的IO操作如果不能马上等到返回结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。 
   * 同步非阻塞方式：发送方发送请求之后，一直等待响应。 接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，取做其他事情。 但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。 当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用） 
   * 异步阻塞方式：发送方向接收方请求后，不等待响应，可以继续其他工作。 接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 （实际不应用）
   * 异步非阻塞方式：发送方向接收方请求后，不等待响应，可以继续其他工作。 接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。 当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）

   <img src="https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png" alt="img" style="zoom: 33%;" />

2. Java IO/NIO：

   * 阻塞IO模型：在读写数据过程中发生阻塞现象，当用户线程发出IO请求后，内核去查看数据是否就绪，若没有则等待数据就绪，而用户线程处于阻塞状态，交出CPU。当数据就绪后，内核将数据拷贝到用户线程，用户线程解除阻塞状态。

     <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom:50%;" />

   * 非阻塞IO模型：用户线程发起一个read操作后，并不需要等待，而是马上得到一个结果值（内核数据是否准备好），但需要不断询问内核数据是否就绪，一直占用CPU。

     <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom:50%;" />

   * 多路复用IO模型：有一个线程不断去轮询多个socket状态，只有当socket真正有读写事件时，才调用实际的IO读写操作。它由三大核心部分构成：Channel、Buffer、Selector。它基于Channel和Buffer进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中，Selector用于监听多个通道的事件，因此可以说NIO是面向**缓冲区**操作的。

     ![img](https://upload-images.jianshu.io/upload_images/13449209-300fd48a7251c327.png?imageMogr2/auto-orient/strip|imageView2/2/w/654/format/webp)

   * 信号驱动IO模型：当用户线程发起一个IO请求操作，会给对应的socket注册一个**信号函数**，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用**IO读写操作**来进行实际的IO请求操作。

   * 异步IO模型：只需要发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据，不需要在用户线程中调用IO函数进行实际的读写操作。

     <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:50%;" />

3. java泛型的类型擦除：

   java泛型是伪泛型，在编译期间，所有的泛型信息都会被擦除，即类型擦除。

4. 重载与重写的区别：

   > https://zhuanlan.zhihu.com/p/369229137
   >
   > https://zhuanlan.zhihu.com/p/64732121

   | 区别点     | 重载方法 | 重写方法                                                     |
   | ---------- | -------- | ------------------------------------------------------------ |
   | 发生范围   | 同一个类 | 子类                                                         |
   | 参数列表   | 必须修改 | 一定不能修改                                                 |
   | 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
   | 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
   | 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
   | 发生阶段   | 编译期   | 运行期                                                       |

5. 深拷贝与浅拷贝：

   >https://segmentfault.com/a/1190000010648514

   * **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
   * **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。

   ![deep and shallow copy](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg)

6. transient关键字：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。`transient` 只能修饰变量，不能修饰类和方法。

7. Arrays.asList()使用问题：

   * **传递的数组必须是对象数组，而不是基本类型。**当传入一个原生数据类型数组时，`Arrays.asList()` 的真正得到的参数就不是数组中的元素，而是数组对象本身！
   * `Arrays.asList()` 方法返回的并不是 `java.util.ArrayList` ，而是 `java.util.Arrays` 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。

8. StringBuilder、StringBuffer的扩容机制：

   > https://www.cnblogs.com/DMingO/p/13407303.html

   1. 新的字符串的长度超过了底层原char数组`value`的大小，才需要进行扩容
   2. 先尝试默认扩容，将新容量变成 (**value**.**length** << 1) + 2 ，也就是两倍的原数组长度再加二
   3. 若默认扩充后的值还是小于至少容量的值，直接扩充到当前需要的至少容量大小；
   4. 经过前两步骤确定的新数组大小，若大于Interger.MAX_VALUE,则报异常，若小于等于0，则新数组大小改为`Interger.MAX_VALUE -8`
   5. 确定了新数组的值后，通过`Arrays.copy(value,newCapactity)`进行复制。最终给value数组完成扩容。

9. next()和nextLine()区别：

   * next()以空格、回车、tab键作为结束符，对于字符串头部的空格会自动忽略；
   * nextLine()仅以回车键当作结束符。

10. hasNext()和hasNextLine()区别：

    * `hasNext()`方法会判断接下来是否有非空字符，如果有，则返回`true`，否则返回`false`；
    * `hasNextLine()` 方法会根据行匹配模式去判断接下来是否有一行(包括空行)，如果有，则返回`true`，否则返回`false`。

11. String为何设计成不可变？

    > https://blog.csdn.net/geofferysun/article/details/78104676?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control

    * 字符串常量池的需要，如果可变则用一个引用改变字符串将导致其他引用值错误；
    * HashCode缓存，String不变则可以保障hashcode的唯一性，不需要每次使用重新计算hashcode；
    * 安全性更高，字符串被广泛用于其他java类的参数，如果可变则会导致在反射中的安全问题；
    * 不可变对象自然是线程安全的，能够在不同的线程间进行共享，确保线程安全；

12. ConcurrentHashMap扩容机制：

    * JDK1.7版本基于segment分段锁实现，每个segment相当于一个小的HashMap，内部扩容和HashMap扩容逻辑相似，先生成新的数组，然后转移元素到新数组中；
    * JDK1.8支持多线程同时扩容，在转移元素前，先将原数组分组，将每组分给不同的线程进行元素转移，每个线程负责一组或多组。

13. java内部实现equals()方法：

    * 先比较两个对象的引用地址是否相同，相同则返回true；
    * 然后比较另一个对象是否为空或者两者的class类型是否相同，如果为空或类型不同则返回false；
    * 最后比较两个对象内的元素内容是否相同。

    ```java
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
    
        Person person = (Person) o;
    
        return name != null ? name.equals(person.name) : person.name == null;
    }
    ```

14. java接口可以继承多个接口，但类不可以继承多个类，因为会产生**菱形继承**问题，即如果两个父类有相同方法名称的方法，此时子类不知道去调用哪个方法。而针对于实现接口并继承父类的情况来讲，即使接口和父类中的方法名相同，如果子类不去实现（重写）此方法，则调用父类方法，否则调用实现的方法，不会产生问题。

    ```java
    public class Animal extends AbstractCreature implements Pet{
        @Override
        public void eat() {
            System.out.println("Animal.eat");
        }
    
        public static void main(String[] args) {
            new Animal().eat();
        }
    }
    
    interface Pet{
        void eat();
    }
    
    abstract class AbstractCreature{
        public void eat(){
            System.out.println("AbstractCreature.eat");
        }
    }
    ```

15. 接口中的一些关键知识点：

    * 接口不能用于实例化对象；
    * 接口中没有构造方法；
    * 接口中所定义的方法必须是抽象方法，jdk1.8后允许使用default关键字修饰非抽象方法；
    * 接口修饰符被隐式指定为**public abstract**；
    * 接口中每一个方法会被隐式指定为且只能是**public abstract**；
    * 接口中可以含有变量，但也会被隐式指定为**public static final**；
    * JDK 1.8 以后，接口里可以有静态方法和方法体；
    * JDK 1.9 以后，允许将方法定义为 private；

16. java内部类只在当前外部类的作用域内可见，内部类的变量成员也只在内部类中可见。

17. 为何要重写equals和hashcode方法？

    > https://zhuanlan.zhihu.com/p/61307537

    自定义对象作为key时要重写hashcode和equals方法，因为要比较两个对象，是先比较hashcode，再比较equals方法，从object继承的hashcode和equals方法都是比较的内存地址，由于自定义的两个对象，内存地址肯定不一致，但是我们可能创建的入参是一样的，所以我们希望它们是相等的。

    * 相同的对象必然导致相同的哈希值。

    * 不同的哈希值必然是由不同对象导致的。
    * **必须保证重写后的equals方法认定相同的两个对象拥有相同的哈希值**。

18. ConcurrentHashMap的使用：

    * Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。
    * Java7中的Segment继承了ReentranLock，通过tryLock()获取锁，获取不到使用`scanAndLockForPut`方法继续获取，即不断自旋trylock()来获取锁，当自旋次数大于指定次数时，使用 `lock()` 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。
    * Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 **Segment 数组 + HashEntry 数组 + 链表** 进化成了 **Node 数组 + 链表 / 红黑树**，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。
    * java8中通过当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。如果当前位置的 `hashcode == MOVED == -1`,则需要进行扩容。如果都不满足，则利用 synchronized 锁写入数据。如果数量大于 `TREEIFY_THRESHOLD` 则要转换为红黑树。

19. HashMap中当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。8的时候转换为红黑树，6的时候**退转回链表**。

    > https://juejin.cn/post/6844904120902483976

20. 

#### 二、JVM知识难点

1. JVM内存区域：主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【java堆、方法区】和直接内存。线程共享区域随虚拟机的启动/关闭而创建/销毁。

   程序计数器：当前线程所执行的字节码行号指示器；

   虚拟机栈：描述java方法执行的内存模型，每个方法执行同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。栈帧随着方法调用而创建，随着方法结束而销毁。

   <img src="https://pic3.zhimg.com/80/v2-9839c3a585cf000c1a059601a30e086e_1440w.jpg" alt="img" style="zoom: 67%;" />

   本地方法区：为Native方法服务。

   堆：创建的对象和数组都保存在这块内存区域中，从GC角度可以分为新生代和老年代。

   方法区/永久代：用于存储被JVM加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据。常量池用于存放编译期间生成的各种**字面量**和**符号引用**，将在类加载后存放到方法区的运行时常量池中。

   

   <img src="https://segmentfault.com/img/remote/1460000037428083" alt="img" style="zoom:67%;" />

2. JVM方法区和元空间的关系：

   > https://zhuanlan.zhihu.com/p/344537168

   jdk1.8以后，使用元空间取代了方法区，元空间存放在堆外内存中，方法区可以看作独立于java堆的内存空间，也会产生内存溢出错误。

   元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用**本地内存**。

   * 内存区域不同：永久代在逻辑上是堆的一部分，和新生代和老年代地址是连续的，而元空间属于本地内存。

   * 存储内容不同：1.7永久代中存储类的元信息以及静态变量以及运行时常量池(字符串常量池在1.7中就已经从永久代移到了堆中)，而在1.8中元空间来存储类的元信息和常量池，而将静态变量放到了堆中。这里需要提一下字符串常量池，1.8中字符串常量池在本地内存中，但存储的是字符串对象的引用。

3. 静态链接与动态链接：

   静态链接：当一个字节码文件被装载进jvm内部时，被调用的目标方法在编译期可知，且运行期保持不变。使用静态链接的方式将符号引用转为直接引用称为**早期绑定**。

   动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期间调用方法的符号引用转换为直接引用。在程序运行期间根据实际的类型绑定相关方法称为**晚期绑定**。

4. JVM本地方法栈和堆：

   > https://segmentfault.com/a/1190000037428080

5. JVM中类的加载机制：指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内。

   >https://www.jianshu.com/p/0e58d57a8133
   >
   >https://zhuanlan.zhihu.com/p/33509426

   * 加载：把class字节码文件从各个来源通过类加载器装载入内存中。

   * 验证：主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。

   * 准备：主要是为类变量（注意，不是实例变量）分配内存，并且赋予**初值**，是Java虚拟机根据不同变量类型的默认初始值，比如8种**基本类型**的初值，默认为0；**引用类型**的初值则为null；**常量**的初值即为代码中设置的值。

   * 解析：将常量池内的符号引用替换为直接引用的过程。

   * 初始化：主要是对**类变量**初始化，是执行类构造器的过程，只对static修饰的变量或语句进行初始化。

     <img src="https://pic4.zhimg.com/80/v2-ecf6c3d0f5146029e9693d6223d23afb_1440w.jpg" alt="img" style="zoom:67%;" />

6. 类加载器：

   * 启动类加载器(Bootstrap ClassLoader)：加载lib目录中的类库；
   * 扩展类加载器(Extension ClassLoader)：加载lib/ext目录中的类库；
   * 应用程序类加载器(Application ClassLoader)：加载用户路径上的类库。

7. 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。

   **目的**：

   * 通过委派的方式，可以避免类的重复加载，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。
   * 保证了安全性，防止类被随意替换。

   

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/4/16465fe65c8f85b4~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:67%;" />

8. 破坏双亲委派模型：

   > https://bbs.huaweicloud.com/blogs/273624

   * 自定义类加载器，重写其中的loadClass方法，使其不进行双亲委派；  

   * 通过**线程上下文类加载器**的传递性，让父类加载器中调用子类加载器的加载动作；

   * 为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。
   
   * 应用场景：Tomcat为了实现**web应用间加载隔离**，自定义了类加载器，每个`Context`代表一个web应用，都有一个`webappClassLoader`。再如**热部署、热加载**的实现都是需要自定义类加载器的。破坏的位置都是跳过`AppClassLoader`。
   
     JNDI服务使用线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作。
   
9. java字符串常量池：

   * **intern()**：String::intern()是一个本地方法，其作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象引用，否则将该字符串添加到常量池中并返回新建对象的引用。

   * String和new String()的区别：前者储存在常量存储区的字符串常量池中，后者存储在堆中。常量池中相同的字符串只会有一个，但是new String()，每new一个对象就会在堆中新建一个对象，不管这个值是否相同。

   * ”java“字符串在sun.misc.Version中已经存在，因此字符串常量池中已经有它的引用。

     ```java
     String str1 = new StringBuilder("hello").append("world").toString();
     System.out.println(str1);
     String str = "helloworld";
     System.out.println(str.intern());
     System.out.println(str1 == str1.intern()); # false
     System.out.println(str == str1.intern()); # true
     
     String str2 = new StringBuilder("ja").append("va").toString();
     System.out.println(str2);
     System.out.println(str2.intern());
     System.out.println(str2 == str2.intern()); # false
     ```

10. 如何判断一个对象是否可以回收：

   > https://cloud.tencent.com/developer/article/1656844

   * 引用计数法：一个对象如果没有任何与之关联的引用，即引用计数为0，则说明对象不太可能被用到，则是可回收对象，但会存在相互循环引用的问题。

   * 可达性分析：通过一系列GC roots对象作为起点进行搜索，如果在GC roots和一个对象之间没有可达路径，则称该对象不可达。但不可达对象不等价于可回收对象，至少要经过两次标记过程都为可回收对象，才可以进行回收。对于第一次不可达对象会进行一次筛选，筛选条件是此对象是否有必要执行**finalize()方法**，若有必要执行则放置在一个F-Queue队列，等待虚拟机建立的Finalizer线程执行finalize()方法来调用，如果对象与引用链上任意对象建立连接，则移除队列不被清除。

     <img src="https://pic2.zhimg.com/80/v2-1b5f1a5869d24b3f1c31b69d853327d5_1440w.jpg" alt="img" style="zoom: 67%;" />

     可以作为GC Roots的对象：
     
     - 虚拟机栈（栈帧中的本地变量表）中引用的对象；
     - 方法区中类静态属性引用的对象；
     - 方法区中常量引用的对象；
     - 本地方法栈中JNI（即一般说的Native方法）引用的对象。

11. 分代收集算法：新生代采用复制算法，老年代采用标记整理算法。

    > https://zhuanlan.zhihu.com/p/45558897

    - **对象优先在Eden区分配**
    - **大对象直接进入老年代**
    - **长期存活的对象进入老年代**
    - **对象年龄的动态判断**
    - **空间分配担保**

12. java四种引用类型：

    * 强引用：将一个对象赋给一个引用变量，例如Object obj = new Object()，处于可达状态，只要强引用存在则永远不会被回收；
    * 软引用：使用SoftReference类来实现，当系统内存空间不足时才会被回收；
    * 弱引用：使用WeakReference类来实现，它的生命只能存活到下一次垃圾收集之前；
    * 虚引用：使用PhantomReference类来实现，主要作用是跟踪对象被垃圾回收的状态。

13. 垃圾收集器：

    * 新生代收集器：

      - Serial收集器：单线程下采用**复制算法**的基本垃圾收集器；
      - ParNe收集器：Serial收集器的多线程版本；
      - Parellel Scavenge收集器：主要关注点在于达到一个可控制的**吞吐量**。

    * 老年代收集器：

      - Serail Old收集器：单线程使用**标记整理算法**的垃圾收集器；
      - Parellel Old收集器：Parellel Scavenge的老年代版本，使用多线程的标记整理算法；

      * CMS收集器：基于**标记清除算法**的并发收集器，主要目标是获取最短垃圾回收停顿时间。主要分为四步：初始标记、并发标记、重新标记、并发清除。**初始标记**仅仅是标记一下GC Roots能直接关联到的对象，速度很快。**并发标记**阶段就是进行GC Roots追踪的过程，而**重新标记**则是为了修正并发标记期间由于用户程序继续执行可能产生变动的那部分对象的标记记录，此阶段会比初始标记长一些，但远小于并发标记的时间。

        整个阶段**并发标记**和**并发清除**是耗时最长的两个阶段。但是由于CMS收集器是并发执行的，故可以和用户线程一起工作，所以从整体上CMS收集器的工作过程是和用户线程并发执行的。

    * G1(Grabage first)收集器：

      - **并发执行**：通过并发来让java线程同步执行；
      - **分代收集**：不需要配合其他的垃圾收集器；
      - **空间整合**：使用**标记整理算法**实现的，不产生内存碎片；
      - **可以预测的停顿**：精确控制停顿时间，实现低停顿垃圾回收；
      - **区域划分**：将堆内存划分成大小固定的几个独立区域；
      - **优先级区域回收机制**：在后台维护一个优先级列表，根据所允许的收集时间，优先回收垃圾最多的区域。

14. JVM问题排查：

    * jmap查看JVM中**各个区域的使用情况**；
    * jstack查看**线程的运行情况**，比如哪些线程阻塞，是否出现了死锁；
    * jstat查看**垃圾回收情况**。

15. 如何查看线程死锁：

    * 通过jstack命令来进行查看，显示发生死锁的线程；
    * 查询数据库的死锁情况。

16. 线程如何进行通信：

    * 线程之间可以通过共享内存或网络来进行通信；
    * 

17. 

#### 三、数据库总结

1. 事务的四个特性以及隔离级别：

   >https://www.cnblogs.com/limuzi1994/p/9684083.html
   >
   >https://zhuanlan.zhihu.com/p/52677680

2. MySQL架构分析：

   > https://juejin.cn/post/6844903505283514381

3. 多版本并发控制MVCC：

   > https://zhuanlan.zhihu.com/p/147372839
   >
   > https://zhuanlan.zhihu.com/p/324440184
   >
   > https://zhuanlan.zhihu.com/p/66791480
   >
   > https://zhuanlan.zhihu.com/p/52977862

   通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。通过在每行记录后面保存两个隐藏的列，一列保存了行的创建时间，一个保存行的过期时间。存储的并不是实际的时间值，而是系统版本号。每一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

   InnoDB 实现多版本控制 （MVCC）是通过 ReadView+ UndoLog 实现的，UndoLog 保存了历史快照，ReadView 规则帮助判断当前版本的数据是否可见。

   MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。

   RC(read commit) 级别下同一个事务里面的每一次查询都会获得一个新的read view副本。

   RR(重复读)级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。

4. 聚簇索引与非聚簇索引：

   > https://cloud.tencent.com/developer/article/1541265

   - 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
   - 非聚簇索引：将数据存储与索引分开，索引结构的叶子节点指向了数据的对应行，叶子节点存储的不再是行的物理位置，而是主键值。

5. **Innodb引擎SQL执行的BufferPool缓存机制**：

   > https://zhuanlan.zhihu.com/p/324440184

   ![preview](https://pic4.zhimg.com/v2-82fe912d213bd32cb01a869353ad0557_r.jpg)

   可以保证每个更新请求都是**更新内存BufferPool**，然后**顺序写日志文件**，同时还能保证各种异常情况下的数据一致性。

6. MySQL索引为何用B+树？

   > https://cloud.tencent.com/developer/article/1524767?from=article.detail.1681803

   - InnoDB 存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在 B+ 树中叶子节点存放数据，非叶子节点存放键值+指针。
   - 索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。
   - 因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少。
   
7. MySQL事务与MVCC如何实现的隔离级别：

   > https://zhuanlan.zhihu.com/p/265280977

8. MySQL锁机制：

   > https://zhuanlan.zhihu.com/p/75673270
   >
   > https://zhuanlan.zhihu.com/p/378306056

   ![img](https://pic3.zhimg.com/80/v2-c670ab055879d3b00a4c1b2c232efd72_1440w.jpg)

   - 意向锁：主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁。
   - Record Lock：单个行记录上的锁
   - Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。
   - 一般我们用for update加锁时，其实是加的Gap Lock，但是因为我们经常会将for update加到主键上，所以Gap Lock就降级为行锁。
   - Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围、索引之间的间隙，并且锁定记录本身；目的是为了防止幻读。
   - 在读已提交隔离级别下，若id列上没有索引，SQL会走**聚簇索引的全扫描**进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。
   - 在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。

9. MySQL预防死锁：

   * innodb_lock_wait_timeout 等待锁超时回滚事务：直观方法是在两个事务相互等待时，当一个等待时间超过设置的某一阀值时，对其中一个事务进行回滚，另一个事务就能继续执行。

   * wait-for graph算法来主动进行死锁检测：每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。若存在回路则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务并从新开始

10. MySQL避免死锁：

    * 合理的设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引**定位更少的行，减少锁竞争**。

    * 调整业务逻辑 SQL 执行顺序， 避免 update/delete 长时间持有锁的 SQL 在事务前面。

    * 避免**大事务**，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的几率也更小。

    * 以**固定的顺序**访问表和行。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为 2，1。这样更可能会造成死锁。

    * 在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里`（运行了 start transaction 或设置了autocommit 等于0）`,那么就会锁定所查找到的记录。

    * 尽量按**主键/索引**去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到 “select … where … order by rand();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数据都被锁住。

    * 优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，**减少连接的表**，将复杂 SQL `分解`为多个简单的 SQL。

11. 主从复制：主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

    - binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。

    - I/O 线程 ：负责从主服务器上读取- 二进制日志，并写入从服务器的中继日志（Relay log）。

    - SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

      ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpwqHyYbEIPyeesNicgZ2s5NTsbic5vbEYibPGEG0zpDoWWQZGWWicRfsazEBAZicXHg15KkeDeqy273licQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

12. 读写分离：

    主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

    读写分离能提高性能的原因在于：

    - 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
    - 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
    - 增加冗余，提高可用性。

    读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

    ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpwqHyYbEIPyeesNicgZ2s5NTdSFSNCGjGtjJX0m6iaKL1t7TliaOVnBggj0PJ8cNOPwN2lXJhqDQN8ng/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

13. MySQL不同日志总结：

    > https://www.cnblogs.com/wy123/p/8365234.html
    >
    > https://segmentfault.com/a/1190000023827696
    
    * binlog：用于记录数据库执行的**写入性操作信息**，以二进制形式保存在磁盘中，是mysql的逻辑日志，通过**追加方式**进行写入。主要使用场景有**主从复制**和**数据恢复**。
    * redo log：只记录事务对数据页做了哪些修改。它包括两部分，一个是内存中的日志缓冲（redo log buffer），另一个是磁盘上的日志文件（redo log file），采用**先写日志，再写磁盘**的技术。采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。适用于**崩溃恢复**。
    * undo log：主要记录了数据的逻辑变化，比如一条insert语句中对应一条delete的undo log，便于发生错误时回滚到事务之前的数据状态。
    * 逻辑日志：记录的是sql语句；
    * 物理日志：mysql数据最终保存在数据页中的，物理日志记录就是数据页变更。
    * MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。
    
14. 数据库索引知识：

    > https://mp.weixin.qq.com/s/_9rDde9wRYoZeh07EASNQQ

15. Mysql设置索引失效：

    > https://segmentfault.com/a/1190000015974714
    >
    > https://segmentfault.com/a/1190000021464570

    * 没有符合最左前缀原则；

    * 以%开头的like查询不能利用索引；

    * 字段进行了隐式的数据类型转化；

    * 走索引没有全表扫描效率高。

      <img src="https://segmentfault.com/img/remote/1460000021464574" alt="索引失效的情况" style="zoom: 80%;" />

16. Innodb如何实现事务？

    * Innodb收到一个update语句后，根据条件找到数据所在的页，并将该页缓存在Buffer Pool中；
    * 执行update语句，修改Buffer Pool中数据，即内存中数据；
    * 生成一个redoLog对象，并存入LogBuffer中；
    * 生成undoLog日志，用于事务回滚；
    * 如果事务提交，则把redoLog对象进行持久化，再将Buffer Pool中所修改数据持久化到磁盘中；
    * 如果事务回滚，则利用undoLog日志进行回滚。

17. 组合索引中如果索引的排列顺序不符合索引建立的顺序，仍然可以使用到索引，这是因为mysql查询优化器回修正sql语句应该以什么样的顺序执行效率最高，最后才生成真正的执行计划。即索引的字段可以是**任意顺序**的。

    ```mysql
    SELECT * FROM test WHERE col1=“1” AND clo2=“2”
    SELECT * FROM test WHERE col2=“2” AND clo1=“1”
    ```

18. Mysql中Explain的type详解：

    > https://juejin.cn/post/6844904149864169486

    type类型从快到慢：system>const>eq_ref>ref>range>index>ALL

19. MySQL如何保证数据不丢失？

    > https://juejin.cn/post/6844904117706440718

    * MySQL Server 层的执行器调用 InnoDB 存储引擎的数据更新接口；

    * 存储引擎更新 Buffer Pool 中的缓存页，

    * 同时存储引擎记录一条 redo log 到 redo log buffer 中，并将该条 redo log 的状态标记为 **prepare 状态**；

    * 接着存储引擎告诉执行器，可以提交事务了。执行器接到通知后，会写 binlog 日志，然后提交事务；

    * 存储引擎接到提交事务的通知后，将 redo log 的日志状态标记为 **commit 状态**；

    * 接着根据 innodb_flush_log_at_commit 参数的配置，决定是否将 redo log buffer 中的日志刷入到磁盘。

    将 redo log 日志标记为 prepare 状态和 commit 状态，这种做法称之为**两阶段事务提交**，它能保证事务在提交后，数据不丢失。为什么呢？redo log 在进行数据重做时，只有读到了 commit 标识，才会认为这条 redo log 日志是完整的，才会进行数据重做，否则会认为这个 redo log 日志不完整，不会进行数据重做。

    如果在 redo log 处于 prepare 状态后，buffer pool 中的缓存页（脏页）也还没来得及刷入到磁盘，写完 biglog 后就出现了宕机或者断电，此时提交的事务是失败的，那么在 MySQL 重启后，进行数据重做时，在 redo log 日志中由于该事务的 redo log 日志没有 commit 标识，那么就不会进行数据重做，磁盘上数据还是原来的数据，也就是事务没有提交。

20. 引入redo log机制的必要性：

    * redo log采用顺序写操作，性能更优；
    * 每次磁盘IO写入的数据量更小，耗时更短；
    * 保证了数据的可靠性。

21. MySQL乐观锁实现方式：

    使用**数据版本（Version）记录机制**实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

22. 

#### 四、并发锁和线程池

1. java线程池原理：

   > https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html

   ![图4 任务调度流程](https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png)

2. 线程池种类：线程池接口是ExecutorService。

   * newCachedThreadPool：创建一个可根据需要创建新线程的线程池，适合执行很多短期异步任务的程序。
   * newFixedThreadPool：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行线程。
   * newScheduledThreadPool：可安排在给定延迟后运行命令或定期执行。
   * newSingleThreadExcutor：返回一个线程池，池中只有一个线程，该线程死后可以重启一个新线程来继续执行。

3. 线程池的核心线程数设置：

   > https://www.cnblogs.com/thisiswhy/p/12690630.html

   * CPU密集型：核心线程数为CPU核数+1；
   * IO密集型：2*CPU核心数。

4. 线程阻塞的三种情况：

   * 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待队列中；
   * 同步阻塞：运行线程在获取对象同步锁时，若该同步锁被其他线程占用，则JVM会把该线程放入锁池中；
   * 其他阻塞：运行线程执行sleep()或join()方法，或者发出IO请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join等待线程终止或者超时、IO处理完毕时，线程重新进入可运行状态。

5. java锁：

   > https://cloud.tencent.com/developer/article/1534229

   * 乐观锁：认为读多写少，遇到并发写的可能性低。通过CAS操作实现，CAS是一种原子操作，通过比较内存位置的值和预期原值，一样则更新，否则失败，重复读-比较-更新的操作。
   * 悲观锁：认为写多，遇到并发写的可能性高，每次读写数据的时候都会上锁。java中的悲观锁是Synchronized，AQS框架下的锁则是先尝试CAS乐观锁去获取锁，如果获取不到才会转为悲观锁，如RetreenLock。
   * 自旋锁：如果持有锁的线程能在很短时间内释放锁资源，那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

6. Synchronized同步锁：属于独占式的悲观锁，同时属于可重入锁。

   * 作用于方法时，锁住的是对象的实例(this)； 
   * 作用于静态方法时，锁住的是Class实例，静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程； 
   * 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。

7. volstile关键字：确保变量的更新操作通知到其他线程。

   * 变量可见性
   * 禁止指令重排序

8. ThreadLocal：线程本地变量，其作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件一些公共变量传递的复杂度。

   * ThreadLocal底层通过ThreadLoaclMap来实现，每个Thread对象中都存在一个ThreadLocalMap, Map中的key为ThreadLoacl对象，value为需要缓存的值；
   * ThreadLocal会造成内存泄漏，线程池中的线程不会进行回收，因此需要手动调用ThreadLocal的remove方法，清楚ThreadLocal对象；
   * 主要应用场景是连接管理（一个线程持有一个连接，线程之间不共享同一个连接）。

   ```java
   public class Person {
       private ThreadLocal<String> name = new ThreadLocal<>();
   
       public String getName() {
           return this.name.get();
       }
   
       public void setName(String name) {
           this.name.set(name);
       }
   
       public void remove(){
           this.name.remove();
       }
   }
   public static void main(String[] args) {
           Person person = new Person();
   
           new Thread(new Runnable() {
               @Override
               public void run() {
                   person.setName("librah");
                   try{
                       TimeUnit.SECONDS.sleep(3);
                   }catch (InterruptedException e){
                       e.printStackTrace();
                   }
                   System.out.println("Thread 1: "+person.getName());
                   person.remove();
               }
           }).start();
   
           new Thread(new Runnable() {
               @Override
               public void run() {
                   person.setName("tom");
                   try{
                       TimeUnit.SECONDS.sleep(10);
                   }catch (InterruptedException e){
                       e.printStackTrace();
                   }
                   System.out.println("Thread 2: "+person.getName());
                   person.remove();
               }
           }).start();
       }
   ```

9. java死锁如何避免：破坏循环等待条件。

   * 注意加锁顺序，保证每个线程按同样顺序进行加锁；
   * 注意加锁时限，针对锁设置一个超时时间；
   * 注意死锁检查，预防机制确保在第一时间发现死锁并进行解决。

10. 并发编程三要素：

    * 原子性：不可分割的操作；
    * 有序性：程序执行顺序和代码顺序一致；
    * 可用性：一个线程对共享变量的修改，其他线程也可以看到。

11. volatile如何保证可见性和有序性：

    * 在对volatile修饰变量进行修改时，会直接将CPU高级缓存中的数据写回到主内存中，对这个变量的读取也直接从主内存读取，从而保证了可见性；
    * 在对其进行读写时，会插入**内存屏障**，可以达到禁止重排序的效果，从而保证了有序性。

12. synchronized锁的底层实现：

    > https://zhuanlan.zhihu.com/p/132742291

    Synchronized修饰代码块底层是使用`monitorenter`,`monitorexit`指令实现线程同步。

    - 执行`monitorenter`指令时,线程将尝试获取同步对象的锁(即monitor对象)，若monitor的count变量(记录线程进入次数)为0, 则将count设置为1，_owner设置为当前线程，``.取锁成功.如果线程已拥有该对象锁,则可以重入该锁，重入时count计算器的值也会加一；
    - 指向`monitorexit`指令时，执行器将count计数器减一，当计数器为0时，其他线程将有机会持有。

    `synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

13. synchronzied锁的优化：

    > https://zhuanlan.zhihu.com/p/75880892
    >
    > https://zhuanlan.zhihu.com/p/139793053

    锁升级，由无锁到偏向锁到轻量级锁最后到重量级锁的过程。

    * 偏向锁：**减少统一线程获取锁的代价**。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。如果一个线程获得了锁，那么锁就进入偏向模式，此时`Mark Word`的结构也就变为偏向锁结构，**当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查`Mark Word`的锁标记位为偏向锁以及当前线程ID等于`Mark Word`的ThreadID即可**，这样就省去了大量有关锁申请的操作。

    * 轻量级锁：由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。

    * 重量级锁：重量级锁是由轻量级锁升级而来，当**同一时间**有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。

      <img src="https://pic4.zhimg.com/80/v2-e38737df190f37b0da47dc4e84020a47_1440w.jpg" alt="img" style="zoom: 50%;" />

14. synchronized 和 ReentrantLock 的区别：

    * 两者都是可重入锁；
    * synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API；
    * ReentrantLock 实现了等待可中断机制、公平锁和选择性通知。

15. synchronized 关键字和 volatile 关键字的区别：

    - **`volatile` 关键字**是线程同步的**轻量级实现**，所以 **`volatile `性能肯定比`synchronized`关键字要好** 。但是 **`volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块** 。
- **`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。**
    - **`volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。**
    
16. AQS（抽象队列同步器）：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

    AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。

    AQS定义了独占和共享两种资源共享方式。

    <img src="https://camo.githubusercontent.com/ac2a92061ff7f1176d98be55181fe6615a7137bab4337540f96fc5c2056ba652/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4151532545352538452539462545372539302538362545352539422542452e706e67" alt="AQS原理图" style="zoom:67%;" />

17. 

#### 五、数据结构与算法总结

1. B树和B+树讲解：

   > https://www.cnblogs.com/nullzx/p/8729425.html

2. Java集合框架：

   > https://juejin.cn/post/6844903966103306247

3. 跳跃链表：

   > https://www.cnblogs.com/cscw/p/15086500.html

4. 



#### 六、计算机网络

1. HTTP与HTTPS的区别：

   > https://www.cnblogs.com/wqhwe/p/5407468.html

   HTTPS在HTTP的基础上加入**SSL协议**，SSL依靠**证书**来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

   HTTPS整个访问请求过程：

   （1）客户端使用https的URL访问服务器，要求与服务器建立SSL连接；

   （2）服务器收到请求后，将网站的证书信息（包含公钥）传送给客户端；

   （3）客户端与服务器协商SSL连接的安全等级；

   （4）客户端浏览器建立会话密钥，然后利用网站的公钥将会话密钥加密，传送给网站；

   （5）服务器利用自己的私钥解密出会话密钥；

   （6）服务器利用会话密钥加密与客户端通信。

   ![img](https://pic002.cnblogs.com/images/2012/339704/2012071410212142.gif)

2. HTTP协议不同版本的比较：

   > https://zhuanlan.zhihu.com/p/37387316

   HTTP1.0：

   * 支持POST、HEAD、POST方法；
   * 每一个请求建立一个TCP连接，请求完成之后立马断开连接（导致连接无法复用和队头阻塞）。

   HTTP1.1：

   * keepalive连接：允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，以便未来的HTTP请求重用现在的连接，直到客户端或服务器端决定将其关闭为止。
   * chunked编码传输：该编码将实体分块传送并逐块标明长度，直到长度为0块表示传输结束，这在实体长度未知时特别有用(比如由数据库动态产生的数据)。
   * 字节范围请求：HTTP1.1支持传送内容的一部分，通过在请求消息中引入了range头域来实现，它允许只请求资源的某个部分。
   
   HTTP2.0：
   
   * 多路复用：允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息；
   * 二进制分帧：应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码；
   * 首部压缩：使用了专门为首部压缩而设计的 HPACK 算法；
   * 服务器推送：在客户端请求之前发送数据的机制，在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。

3. DNS：域名系统，作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。

4. TCP协议如何保证可靠传输：

   * TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
   * **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
   * TCP 的接收端会丢弃重复的数据。
   * **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
   * **拥塞控制：** 当网络拥塞时，减少数据的发送。
   * **ARQ 协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
   * **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

5. 流量控制和拥塞控制的区别：

   > https://zhuanlan.zhihu.com/p/37379780

   拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。

   流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

   拥塞控制是一个**全局性的过程**，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个**端到端的问题**。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

6. 连续ARQ协议：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

7. TCP拥塞控制过程：

   - **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。
   - **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.
   - **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

8. 打开网页的整个过程：

   ![img](https://camo.githubusercontent.com/c757ddcd23ab760aabb28c35adeadb49fe872f47f0dfb3ed5e4144ca9aa704cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f75726ce8be93e585a5e588b0e5b195e7a4bae587bae69da5e79a84e8bf87e7a88b2e6a7067)

9. select和epoll区别：

   > https://zhuanlan.zhihu.com/p/345370853

   * select仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流，只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。
   * epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。

10. 


#### 七、操作系统

1. 进程同步的几种方式：

   > https://www.cnblogs.com/youngforever/p/3250270.html

   * 事件对象(Event)：包括有信号和无信号两种状态，在线程访问某资源前，需要等待某一事件的发生。
   * 临界区对象(CriticalSection)：只能用于同一进程的线程之间共享资源处理，同一进程内各线程对它的访问是互斥进行的。
   * 互斥体对象(Mutex)：用来协调多个线程对共享资源的互斥访问，同一时刻只能被一个线程占用。
   * 信号量对象(Semaphore)：同步对象，允许同时对多个线程共享资源进行访问，用于限制并发资源的线程数。

2. 进程通信的几种模式：

   * 共享内存：建立一个共享存储区，用于多个进程的通信访问；
   * 消息传递：由发送方形成，通过一定机制传递给接收方的一组信息；
   * 管道：信息流缓冲结构，分为匿名管道(父子进程间传输数据)和命名管道（有名称的，可跨进程或网络来传输数据）；
   * 套接字：不同机器间的进程通信；
   * 信号量：控制多个进程对共享资源的访问；
   * 信号：用于通知接收进程某个事件已经发生。

3. 进程与线程的定义、关系及区别：

   > https://www.cnblogs.com/wuaihua/p/7467697.html

   * 进程指在系统中能独立运行并作为资源分配的基本单位，由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。进程实体由程序段、相关数据段和PCB（进程控制块，包含进程的描述和控制信息，是进程存在的唯一标志）三部分构成了进程实体。
   * 线程是进程的一个实体，作为系统调度和分派的基本单位，是进程内的一个相互独立的可执行单元。
   * **进程**就是一个应用程序在处理机上的**一次执行过程**，它是一个动态的概念，而**线程**是进程中的一部分，进程包含多个线程在运行。**进程作为分配资源的基本单位**，而把**线程作为独立运行和独立调度的基本单位**。
   * 进程与线程的区别：
     * 调度：线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位；
     * 并发性：进程之间可以并发执行，在一个进程中的多个线程之间也可以并发执行；
     * 拥有资源：进程是拥有系统资源的一个独立单位，而线程一般不能拥有自己的资源；
     * 独立性：在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多，这是因为为了防止进程之间彼此干扰和破坏；
     * 系统开销：进程切换开销远大于线程切换的开销；
     * 支持多处理机系统：可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行。

4. 进程调度算法：

   * 先来先服务调度算法；
   * 短作业优先调度算法；
   * 基于优先数的调度算法：给每一个进程设置一个优先级，调度时优先选择高优先级的进程占用cpu；
   * 时间片轮转法：规定一个时间片长度作为允许一个进程运行的时间；
   * 多级反馈队列调度算法：引入多个就绪队列，通过对各个队列的区别对待，达到综合调度。

5. 死锁产生的必要条件：

   * 资源互斥使用
   * 不可剥夺控制
   * 请求并保持
   * 循环等待

6. 分区分配算法：

   * 最先适应算法：将所有空闲分区按照地址递增顺序排列，从头查找，符合要求的第一个分区就是所找分区；
   * 邻近适应算法：按分区的先后次序，从上次分配的分区查找，到最后分区时再回到开头，找到第一个符合要求的分区；
   * 最佳适应算法：将所有空闲分区按照容量递增顺序排列，从小到大查找，找到最合适的分配；
   * 最坏适应算法：容量递减排列，最前面的最大空闲分区就是所找分区；

7. 内存管理机制：

   * 块式管理：将内存分为几个固定大小的块，每个块中只包含一个进程；
   * 页式管理：将内存分为大小相等且固定的页形式，通过页表对应逻辑地址和物理地址；
   * 段式管理：将内存分为一段段空间，每个段定义了一组逻辑信息，包括主程序段、子程序段、数据段以及栈段等，通过段表对应逻辑地址和物理地址；
   * 段页式管理：先将内存划分成若干段，每个段再分成若干页。

8. 快表：特殊的高速缓冲存储器，作为页表cache，提高了访问速率。

   * 根据虚拟地址中的页号查快表；
   * 如果该页在快表中，直接从快表中读取相应的物理地址；
   * 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
   * 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

9. 多级页表：避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。

10. 分页和分段关系与区别：

    * 共同点：
      * 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。
      * 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。

    * 区别：
      * 页的大小是固定的，由操作系统决定；而段的大小**不固定**，取决于我们当前运行的程序。
      * 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。

11. 虚拟内存：虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），**它定义了一个连续的虚拟地址空间**，并且 **把内存扩展到硬盘空间**。

    * 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；
    * **缺页中断**：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；
    * **虚拟地址空间** ：逻辑地址到物理地址的变换

12. 请求分页与分页存储区别：根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。

13. 页面置换算法：

    - **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
    - **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
    - **LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
    - **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。

14. 

#### 八、Spring框架

1. Spring启动流程：

   * 首先进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中；
   * 然后筛选出饿汉式加载的单例BeanDefinition进行创建Bean，对于Prototype作用域类型的Bean则在获取时进行创建；
   * 利用BeanDefinition对象创建Bean就是Bean的创建生命周期；
   * 单例Bean创建完后，Spring会发布一个容器启动事件；
   * Spring扫描是通过BeanFactoryPostProcessor来实现，依赖注入通过BeanPostProcessor来实现。

2. Spring的事务机制：

   * 底层基于数据库事务和AOP机制的；
   * 对于使用@Transactional注解的Bean，Spring会创建一个代理对象作为Bean；
   * 利用事务管理器创建一个数据库连接，并修改数据库连接的autocommit属性为false；
   * 执行当前方法，无异常则直接提交事务，如果有异常需要回滚则回滚事务；
   * 其事务隔离级别对应数据库的隔离级别；
   * 传播机制是Spring事务自己实现的，基于数据库连接来完成。

3. Spring事务传播机制详解：

   > https://zhuanlan.zhihu.com/p/148504094

   * 事务传播的七种类型：
     * REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务；
     * SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行；
     * MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常；
     * REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务，在执行时，不论当前是否存在事务，总是会新建一个事务；
     * NOT_SUPPORTED：始终以非事务方式执行,如果当前存在事务，则挂起当前事务；
     * NEVER：不使用事务，如果当前事务存在，则抛出异常；
     * NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）。
   * 失效情况：不是被代理对象进行调用时，不会生效；如果方法是private也会失效，因为cglib是基于父子类来实现的，子类不能覆盖父类的private方法。

4. 动态代理底层实现：

5. 常用SpringBoot注解及其实现：

   * @SpringBootApplication标识了一个SpringBoot工程，实际上是三个注解的组合。
     * @SpringBootConfiguration：表示启动类是一个配置类；
     * @EnableAutoConfiguration：用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean；
     * @ComponentScan：表示扫描路径，默认是启动类所在的当前目录。
   * @Bean注解：用来定义Bean。

6. Spring中Bean线程安全吗？

   Spring本身没有对Bean做线程安全处理，如果Bean无状态，则Bean是线程安全的，有状态则是线程不安全的。

7. Spring中所用到的设计模式：

   > https://zhuanlan.zhihu.com/p/114244039

8. 



#### 九、Redis

1. 数据结构：字符串、哈希表、列表、集合、有序集合。
2. Redis集群策略：
   * 主从模式：实现读写分离，容灾的快速恢复
   * 哨兵模式：能够后台监控主机是否故障，发生故障则根据投票数自动将从库变为主库。
   * Cluster模式：支持多主多从，会按照key进行槽位分配，使得不同key分散到不同主节点上，可支持更大的数据容量。每个主节点拥有多个从节点，主节点宕机后会选举一个从节点成为主节点。



#### 十、设计模式



#### 十一、Linux

1. 应用程序自启动操作：

   * 新建一个脚本 zookeeper
   * 为新建的脚本 zookeeper 添加可执行权限，命令是:`chmod +x zookeeper`
   * 把 zookeeper 这个脚本添加到开机启动项里面，命令是：`chkconfig --add zookeeper`
   * 如果想看看是否添加成功，命令是：`chkconfig --list`

2. 查看当前系统正在运行的进程，例如redis：

   ```shell
   ps -ef | grep redis
   ps -aux | grep redis
   ```

3. Linux 检查分析死锁：

   > https://www.jianshu.com/p/e63f8c231a3a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation

   的

4. 

#### 其他知识

1. 分布式锁实现：能够对分布在多台机器中的线程实现共享资源的互斥访问。
   * 基于Mysql的行锁；
   * 基于Zookeeper的顺序节点、临时节点、Watch机制；
   * 基于Redis的消费消费订阅功能、数据超时时间和lua脚本。
2. 