### 文件I/O

#### open函数

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char*pathname,int oflags,mode_t mode);
```

- `pathname`需要打开或者创建文件的名字

- `oflags`：可用来说明此函数的多个选择项

  - `O_RDONLY` 只读打开
  - `O_WRONLY` 只写打开
  - `O_RDWR` 读、写打开

  > `NAMEMAX`是14，而我们却试图在当前目录中创建一个其文件名包含1 5个字符的新文件，按照传统，早期的系统V版本，允许这种使用方法，但是总是将文件名截短为14个字符，而`BSD`类的系统则返回出错`ENAMETOOLONG`

#### creat函数

```C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int creat(const char pathname,mode_t mode);
// 以只写方式打开所创建的文件
// 若成功为只写打开的文件描述符，若出错为-1
// 等价于下面的
int open(pathname,O_WRONLY|O_CREAT|O_TRUNC,mode);
```

#### close函数

```C
#include <unistd.h>
int close(int filedes);
```

关闭一个文件时也释放该进程加在该文件上的所有记录锁，而当一个进程终止时，它所有的打开文件都由内核自动关闭。很多程序都使用这一功能而不显式地用`close`关闭打开的文件

#### lseek函数

```C
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fildes, off_t offset, int whence);
```

参数`whence`

- `SEEK_SET`：则将该文件的位移量设置为距文件开始处`offset`个字节处
- `SEEK_CUR`：则将该文件的位移量设置为当前值加`offset`，`offset`可正可负
- `SEEK_END`：则将该文件的位移量设置为文件长度加`offset`, `offset`可为正或负

若`lseek`成功执行，则返回新的文件位移量

#### raed函数

```C
#include <unistd.h>
ssize_t read(int filedes, void *buff, size_t nbytes);
// 返回：读到的字节数，若已到文件尾为0，若出错为- 1
```

- 读普通文件时，在读到要求字节数之前已到达了文件尾端。例如，若在到达文件尾端之前还有30个字节，而要求读100个字节，则`read`返回30，下一次再调用`read`时，它将返回0

- 当从终端设备读时，通常一次最多读一行
- 当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数
- 某些面向记录的设备，例如磁带，一次最多返回一个记录

#### write函数

```C
#include <unistd.h>
ssize_t write(int filedes, const void *buff, size_t nbytes);
// 返回：若成功为已写的字节数，若出错为- 1
```

对于普通文件，写操作从文件的当前位移量处开始。如果在打开该文件时，指定了`O_APPEND`选择项，则在每次写操作之前，将文件位移量设置在文件的当前结尾处。在一次成功写之后，该文件位移量增加实际写的字节数。

#### Unix文件共享&&原子操作

![Unix file share](../Image/Unix file share.png)

原子操作：如果该操作原子地执行，则或者执行完所有步，或者一步也不执行，不可能只执行所有步的一个子集

```c
if (lseek(fd, 0L, 2) < 0) /*position to EOF*/
err_sys("lseek error");
if (write(fd, buff, 100) != 100) /*and write*/
err_sys("write error");
```

假设A与B拥有自己的文件表项，但是共享一个V节点表项（我将其理解为不同的进程同时打开同一个文件），A首先调用`lseek`改变文件偏移量，然后内核切换到B，B也`lseek`改变文件偏移量，A随后的修改将会覆盖部分或者全部B的修改，所以将改变文件偏移量和写入作为一个操作，也就是`open`的`O_APPEND`标志，为原子操作

#### dup和dup2函数

```C
#include <unistd.h>
int dup(int filedes) ;
int dup2(int filedes,int filedes2) ;
// 复制一个显存的文件描述符
```

由`dup`返回的新文件描述符一定是当前`filedes2`可用文件描述符中的最小数值。用`dup2`则可以用`filedes2`参数指定新描述符的数值。如果`filedes2`已经打开，则先将其关闭。如若`filedes`等于`filedes2`，则`dup2`返回`filedes2`，而不关闭它。这些函数返回的新文件描述符与参数`filedes`共享同一个文件表项

#### fcntl函数

```C
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
int fcntl(int filedes,int cmd,.../* inta rg * / ) ;
```

`fcntl`可以改变已经打开文件的性质

- `cmd=F_DUPFD` 复制现存的描述符
- `cmd=F_GETFD或者F_SETFD` 获得/设置文件描述符标记
- `cmd=F_GETFL或者F_SETFL` 获得/设置文件状态标志
- `cmd=F_GETWN或者F_SETWN` 获得/设置异步I / O有权
- `cmd=F_GETLK或者F_SETLK或者F_SETLKW` 获得/设置记录锁

#### ioctl函数

```C
#include <unistd.h> 
#include <sys/ioctl.h>
int ioctl(int filedes,int request,...);
```

### 文件和目录

#### `stat` `lstat` `fstat`获取文件属性

```C
#include <sys/types.h>
#include <sys/stat.h>
int stat(const char *path, struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *path, struct stat *buf);
/****************************************************
*	path:文件名称或者目录名
*	fd:文件描述符
*	stat:见下面的结构体说明
****************************************************/
struct stat {
        dev_t     st_dev;             /* ID of device containing file */          //  文件的设备编号
        ino_t     st_ino;               /* inode number */                                   //  结点
        mode_t    st_mode;     /* protection */                                           //  文件的类型和存取的权限
        nlink_t   st_nlink;         /* number of hard links */                       // 连到该文件的硬链接数目，新建的文件则硬连接数为 1
        uid_t     st_uid;               /* user ID of owner */                                // 用户ID
        gid_t     st_gid;               /* group ID of owner */                             // 组ID
        dev_t     st_rdev;           /* device ID (if special file) */                 // 若此文件为设备文件，则为其设备的编号
        off_t     st_size;              /* total size, in bytes */                             //  文件字节数(文件大小)
        blksize_t st_blksize;   /* blocksize for filesystem I/O */          // 块大小
        blkcnt_t  st_blocks;    /* number of 512B blocks allocated */           // 块数
        time_t    st_atime;       /* time of last access */                                  //  最后一次访问时间
        time_t    st_mtime;     /* time of last modification */                         // 最后一次修改时间
        time_t    st_ctime;       /* time of last status change */                       // 最后一次改变时间
};

// mode_t其实就是普通的unsigned int。其中，最低的9位(0-8)是权限，9-11是id，12-15是类型。
S_IFMT     0170000   bitmask for the file type bitfields
S_IFSOCK   0140000   socket
S_IFLNK    0120000   symbolic link
S_IFREG    0100000   regular file
S_IFBLK    0060000   block device
S_IFDIR    0040000   directory
S_IFCHR    0020000   character device
S_IFIFO    0010000   fifo
S_ISUID    0004000   set UID bit
S_ISGID    0002000   set GID bit (see below)
S_ISVTX    0001000   sticky bit (see below)
S_IRWXU    00700     mask for file owner permissions
S_IRUSR    00400     owner has read permission
S_IWUSR    00200     owner has write permission
S_IXUSR    00100     owner has execute permission
S_IRWXG    00070     mask for group permissions
S_IRGRP    00040     group has read permission
S_IWGRP    00020     group has write permission
S_IXGRP    00010     group has execute permission
S_IRWXO    00007     mask for permissions for others (not in group)
S_IROTH    00004     others have read permission
S_IWOTH    00002     others have write permisson
S_IXOTH    00001     others have execute permission
```



三个函数均是获取文件属性的函数，成功返回0；否则返回-1

- `fstat`：调用`open`函数返回的文件描述符
- `stat`&`lstat`：当文件是符号链接（软链接）是，`lstat`返回是符号链接本身的信息，`stat`返回的是符号链接指向的文件信息

#### 文件类型

1. 普通文件(regular file)：这是最常见的文件类型，这种文件包含了某种形式的数据。
2. 目录文件(directory file)：这种文件包含了其他文件的名字以及指向与这些文件有关信 息的指针。对一个目录文件具有读许可权的任一进程都可以读该目录的内容，但**只有内核**可以写目录文件
3. 字符特殊文件(character special file)：这种文件用于系统中某些类型的设备。
4. 块特殊文件(block special file)：这种文件典型地用于磁盘设备。系统中的所有设备或者 是字符特殊文件，或者是块特殊文件。
5. FIFO：这种文件用于进程间的通信，有时也将其称为命名管道。
6. 套接口(socket)：这种文件用于进程间的网络通信。套接口也可用于在一台宿主机上的进程之间的非网络通信
7. 符号连接(symbolic link)：这种文件指向另一个文件。

