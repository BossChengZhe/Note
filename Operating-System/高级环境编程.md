### 文件I/O

#### open函数

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char*pathname,int oflags,mode_t mode);
```

- `pathname`需要打开或者创建文件的名字

- `oflags`：可用来说明此函数的多个选择项

  - `O_RDONLY` 只读打开
  - `O_WRONLY` 只写打开
  - `O_RDWR` 读、写打开

  > `NAMEMAX`是14，而我们却试图在当前目录中创建一个其文件名包含1 5个字符的新文件，按照传统，早期的系统V版本，允许这种使用方法，但是总是将文件名截短为14个字符，而`BSD`类的系统则返回出错`ENAMETOOLONG`

#### creat函数

```C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int creat(const char pathname,mode_t mode);
// 以只写方式打开所创建的文件
// 若成功为只写打开的文件描述符，若出错为-1
// 等价于下面的
int open(pathname,O_WRONLY|O_CREAT|O_TRUNC,mode);
```

#### close函数

```C
#include <unistd.h>
int close(int filedes);
```

关闭一个文件时也释放该进程加在该文件上的所有记录锁，而当一个进程终止时，它所有的打开文件都由内核自动关闭。很多程序都使用这一功能而不显式地用`close`关闭打开的文件

#### lseek函数

```C
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fildes, off_t offset, int whence);
```

参数`whence`

- `SEEK_SET`：则将该文件的位移量设置为距文件开始处`offset`个字节处
- `SEEK_CUR`：则将该文件的位移量设置为当前值加`offset`，`offset`可正可负
- `SEEK_END`：则将该文件的位移量设置为文件长度加`offset`, `offset`可为正或负

若`lseek`成功执行，则返回新的文件位移量

#### raed函数

```C
#include <unistd.h>
ssize_t read(int filedes, void *buff, size_t nbytes);
// 返回：读到的字节数，若已到文件尾为0，若出错为- 1
```

- 读普通文件时，在读到要求字节数之前已到达了文件尾端。例如，若在到达文件尾端之前还有30个字节，而要求读100个字节，则`read`返回30，下一次再调用`read`时，它将返回0

- 当从终端设备读时，通常一次最多读一行
- 当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数
- 某些面向记录的设备，例如磁带，一次最多返回一个记录

#### write函数

```C
#include <unistd.h>
ssize_t write(int filedes, const void *buff, size_t nbytes);
// 返回：若成功为已写的字节数，若出错为- 1
```

对于普通文件，写操作从文件的当前位移量处开始。如果在打开该文件时，指定了`O_APPEND`选择项，则在每次写操作之前，将文件位移量设置在文件的当前结尾处。在一次成功写之后，该文件位移量增加实际写的字节数。

#### Unix文件共享&&原子操作

![Unix file share](../Image/Unix file share.png)

原子操作：如果该操作原子地执行，则或者执行完所有步，或者一步也不执行，不可能只执行所有步的一个子集

```c
if (lseek(fd, 0L, 2) < 0) /*position to EOF*/
err_sys("lseek error");
if (write(fd, buff, 100) != 100) /*and write*/
err_sys("write error");
```

假设A与B拥有自己的文件表项，但是共享一个V节点表项（我将其理解为不同的进程同时打开同一个文件），A首先调用`lseek`改变文件偏移量，然后内核切换到B，B也`lseek`改变文件偏移量，A随后的修改将会覆盖部分或者全部B的修改，所以将改变文件偏移量和写入作为一个操作，也就是`open`的`O_APPEND`标志，为原子操作

#### dup和dup2函数

```C
#include <unistd.h>
int dup(int filedes) ;
int dup2(int filedes,int filedes2) ;
// 复制一个显存的文件描述符
```

由`dup`返回的新文件描述符一定是当前`filedes2`可用文件描述符中的最小数值。用`dup2`则可以用`filedes2`参数指定新描述符的数值。如果`filedes2`已经打开，则先将其关闭。如若`filedes`等于`filedes2`，则`dup2`返回`filedes2`，而不关闭它。这些函数返回的新文件描述符与参数`filedes`共享同一个文件表项

#### fcntl函数

```C
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
int fcntl(int filedes,int cmd,.../* inta rg * / ) ;
```

`fcntl`可以改变已经打开文件的性质

- `cmd=F_DUPFD` 复制现存的描述符
- `cmd=F_GETFD或者F_SETFD` 获得/设置文件描述符标记
- `cmd=F_GETFL或者F_SETFL` 获得/设置文件状态标志
- `cmd=F_GETWN或者F_SETWN` 获得/设置异步I / O有权
- `cmd=F_GETLK或者F_SETLK或者F_SETLKW` 获得/设置记录锁

#### ioctl函数

```C
#include <unistd.h> 
#include <sys/ioctl.h>
int ioctl(int filedes,int request,...);
```

